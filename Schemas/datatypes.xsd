<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="urn:hl7-org:v3:cdsdt:r2" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="urn:hl7-org:v3:cdsdt:r2" xmlns:dt="urn:hl7-org:v3:cdsdt:r2" elementFormDefault="qualified">
	<xs:annotation>
		<xs:documentation>Specifies data types used.  The data types are a simplified/constrained version of ISO 21090 data types, which is an implementable specification based on the abstract HL7 version 3 data types specification, release 2.</xs:documentation>
	</xs:annotation>
	<xs:simpleType name="Code">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:complexType name="TEL">
		<xs:annotation>
			<xs:documentation>A locatable resource that is identified by a URI, such as a web page, a telephone number (voice, fax or some other resource mediated by telecommunication equipment), an e-mail address, or any other locatable resource that can be specified by a URL.

The address is specified as a Universal Resource Locator (URL) qualified by time specification and use codes that help in deciding which address to use for a given time and purpose.

The value attribute is constrained to be a uniform resource locator specified according to IETF RFCs 1738 and 2806 when used in this datatype. 

Note:  The intent of this datatype is to be a locator, not an identifier; this datatype is used to refer to a locatable resource using a URL, and knowing the URL allows one to locate the object. However some use cases have arisen where a URI is used to refer to a locatable resource. Though this datatype allows for URIs to be used, the resource identified SHOULD always be locatable. A common use of locatable URIs is to refer to SOAP attachments.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence/>
				<xs:attribute name="value" use="required" type="xs:anyURI">
					<xs:annotation>
						<xs:documentation>A uniform resource identifier specified according to IETF RFC 2396. 
The URI specifies the protocol and the contact point defined by that protocol for the resource. 
Examples:  Notable uses of the telecommunication address datatype are for telephone and telefax numbers, e-mail addresses, Hypertext references, FTP references, etc.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="use" use="optional" type="set_TelecommunicationAddressUse">
					<xs:annotation>
						<xs:documentation>One or more codes advising system or user which telecommunication address in a set of like addresses to select for a given telecommunication need. 
The telecommunication use code is not a complete classification for equipment types or locations. Its main purpose is to suggest or discourage the use of a particular telecommunication address. There are no easily defined rules that govern the selection of a telecommunication address. Conformance statements may clarify what rules may apply or how additional rules are applied.
If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationAddressUse code system</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="capabilities" use="optional" type="set_TelecommunicationCapability">
					<xs:annotation>
						<xs:documentation>One or more codes advising a system or user what telecommunication capabilities are known to be associated with the telecommunication address. 
If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationCapability code system</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="useablePeriodOriginalText" use="optional" type="xs:string">
					<xs:annotation>
						<xs:documentation>This attribute is equivalent to the originalText.value attribute within the useablePeriod attribute of this class in the ISO 21090 specification.

The periods of time during which the telecommunication address can be used. 

For a telephone number, this can indicate the time of day in which the party can be reached on that telephone. For a web address, it may specify a time range in which the web content is promised to be available under the given address.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="XP">
		<xs:annotation>
			<xs:documentation>A part of a name or address. Each part is a character string.</xs:documentation>
		</xs:annotation>
		<xs:sequence/>
		<xs:attribute name="value" use="required" type="xs:string">
			<xs:annotation>
				<xs:documentation>The actual string value of the part.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="CO">
		<xs:annotation>
			<xs:documentation>Represents data where coded values are associated with a specific order. 

Note:  CO may be used for things that model rankings and scores, e.g. likert scales, pain, Apgar values, etc, where there is a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite. CO may also be used in the context of an ordered code system. In this case, it may not be appropriate or even possible to use the value attribute, but CO may still be used so that models that make use of such code systems may introduce model elements that involve statements about the order of the terms in a domain.

The relative order of values in a code system need not be independently obvious in the literal representation of the CO. It these circumstances, is expected that an application will look up the ordering of these values from some definition of the code system. 

Some of the code systems will directly assign numerical value to the concepts that are suitable for some mathemetical operations.

Though it would generally make sense, applications SHOULD not assume that the translations of the code, if provided, will have the same ordering as the CO. Translations SHALL not be considered when the ordering of the code system is determined.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="code" type="CD" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>A code representing the definition of the ordinal item</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="value" use="optional" type="Decimal">
					<xs:annotation>
						<xs:documentation>A numerical value associated with the coded ordinal value.
The value may be constrained to an integer in some contexts of use. If code is nonNull, value SHALL only be nonNull if the code system explicitly assigns a value to the concept.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RTO_INT">
		<xs:annotation>
			<xs:documentation>A ratio of integers constructed as the quotient of a numerator integer value divided by a denominator integer value.
Common factors in the numerator and denominator are not automatically cancelled out. 
The RTO datatype supports titers (e.g., 1:128) and other quantities produced by laboratories that truly represent ratios. Ratios are not simply structured numerics, particularly blood pressure measurements (e.g. 120/60) are not ratios.
Notes: 
1.    Ratios are different from rational numbers, i.e., in ratios common factors in the numerator and denominator never cancel out. A ratio of two real or integer numbers is not automatically reduced to a real number. This datatype is not defined to generally represent rational numbers. It is used only if common factors in numerator and denominator are not supposed to cancel out. This is only rarely the case. For observation values, ratios occur almost exclusively with titers. In most other cases, REAL should be used instead of the RTO.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="numerator" type="INT" minOccurs="1" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The integer quantity that is being divided in the ratio.  This represents the numerator.expression.value from the ISO21090 datatypes.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="denominator" type="INT" minOccurs="1" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The integer quantity that divides the numerator in the ratio. 
The denominator SHALL not be zero.  This represents the denominator.expression.value from the ISO 21090 datatypes.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_INT">
		<xs:annotation>
			<xs:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="low" type="INT" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the low limit. If the low limit is not known, it may be null.
The low limit SHALL NOT be positive infinity.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="high" type="INT" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the high limit. If the high limit is not known, it may be null.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="lowIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called lowIsClosed in the ISO 21090 specification.

Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="highIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called highIsClosed in the ISO 21090 specification.

Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ANY" abstract="true">
		<xs:annotation>
			<xs:documentation>Defines the basic properties of every data value. This is conceptually an abstract type, meaning that no proper value can be just a data value without belonging to any concrete type. Every public concrete type is a specialization of this general abstract DataValue type.

This class is maintained despite the lack of attributes to maintain compatibility with the ISO 21090 data structure.</xs:documentation>
		</xs:annotation>
		<xs:sequence/>
	</xs:complexType>
	<xs:complexType name="QTY" abstract="true">
		<xs:annotation>
			<xs:documentation>The quantity datatype is an abstract generalization for all datatypes whose domain values has an order relation (less-or-equal) and where difference is defined in all of the datatype's totally ordered value subsets.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EN">
		<xs:annotation>
			<xs:documentation>A name for a person, organization, place or thing. 

Examples:   Jim Bob Walton, Jr., Health Level Seven, Inc., Lake Tahoe, etc. An entity name may be as simple as a character string or may consist of several entity name parts, such as, Jim, Bob, Walton, and Jr., Health Level Seven, and Inc.

Entity names are essentially sequences of entity name parts, but add a "use" code.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="part" type="ENXP" minOccurs="1" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A sequence of name parts, such as given name or family name, prefix, suffix, etc.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="use" use="optional" type="set_EntityNameUse">
					<xs:annotation>
						<xs:documentation>A set of codes advising a system or user which name in a set of names to select for a given purpose. 
A name without specific use code might be a default name useful for any purpose, but a name with a specific use code would be preferred for that respective purpose. Names SHOULD not be collected without at least one use code, but names MAY exist without use code, particularly for legacy data.
If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNameUse2 code system.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_RTO_INT">
		<xs:annotation>
			<xs:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds.
</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="low" type="RTO_INT" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the low limit. If the low limit is not known, it may be null.
The low limit SHALL NOT be positive infinity.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="high" type="RTO_INT" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the high limit. If the high limit is not known, it may be null.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="lowIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called lowIsClosed in the ISO 21090 specification.
Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="highIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called highIsClosed in the ISO 21090 specification.
Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="REAL">
		<xs:annotation>
			<xs:documentation>Fractional numbers. Typically used whenever quantities are measured, estimated, or computed from other real numbers. The typical representation is decimal, where the number of significant decimal digits is known as the precision.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence/>
				<xs:attribute name="value" use="required" type="Decimal">
					<xs:annotation>
						<xs:documentation>The value of the REAL. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ST">
		<xs:annotation>
			<xs:documentation>The character string datatype stands for text data, primarily intended for machine processing (e.g., sorting, querying, indexing, etc.) or direct display. Used for names, symbols, presentation and formal expressions.

A ST SHALL have at least one character or else be null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence/>
				<xs:attribute name="value" use="required" type="xs:string">
					<xs:annotation>
						<xs:documentation>The actual content of the string. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PQ">
		<xs:annotation>
			<xs:documentation>A dimensioned quantity expressing the result of measuring.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence/>
				<xs:attribute name="value" use="required" type="Decimal">
					<xs:annotation>
						<xs:documentation>The number which is multiplied by the unit to make the PQ.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="unit" use="required" type="Code">
					<xs:annotation>
						<xs:documentation>The unit of measure specified in the Unified Code for Units of Measure (UCUM). 
UCUM defines two forms of expression, case sensitive and case insensitive. PQ uses the case sensitive codes. The codeSystem OID for the case sensitive form is 2.16.840.1.113883.6.8. The default value for unit is the UCUM code "1" (unity).
Equality of physical quantities does not require the values and units to be equal independently. Value and unit is only how we represent physical quantities. For example, 1 m equals 100 cm. Although the units are different and the values are different, the physical quantities are equal. Therefore one should never expect a particular unit for a physical quantity but instead allow for automated conversion between different comparable units. 
The unit SHALL come from UCUM, which only specifies unambiguous measurement units. Sometimes it is not clear how some measurements in healthcare map to UCUM codes.
Note: The general pattern for a measurement is  value unit of Thing. In this scheme, the PQ represents the  value and the unit, and the Thing is described by some coded concept that is linked to the PQ by the context of use. This maps obviously to some measurements, such as Patient Body Temperature of 37 Celsius, and 250 mg/day of Salicylate.
However for some measurements that arise in healthcare, the scheme is not so obvious. Two classic examples are 5 Drinks of Beer, and 3 Acetaminophen tablets. At first glance it is tempting to classify these measurements like this: 5 drinks of Beer and 3 Acetaminophen tablets. The problem with this is that UCUM does not support units of "beer", "tablets" or "scoops".
The reason for this is that neither tablets or scoops are proper units. What kind of tablets? How big is the glass? In these kinds of cases, the concept that appears to be a unit needs to further specified before interoperability is established. If a correct amount is required, then it is generally appropriate to specify an exact measurement with an appropriate UCUM unit. If this is not possible, then the concept is not part of the measurement. UCUM provides a unit called unity for use in these cases. The proper way to understand these measurements as 3 1 Acetaminophen tablets, where 1 is the UCUM unit for unity, and the Thing has a qualifier. The context of use will need to provide the extra qualifying information.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_RTO_PQ">
		<xs:annotation>
			<xs:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="low" type="RTO_PQ" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the low limit. If the low limit is not known, it may be null.
The low limit SHALL NOT be positive infinity.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="high" type="RTO_PQ" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the high limit. If the high limit is not known, it may be null.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="lowIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called lowIsClosed in the ISO 21090 specification.

Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="highIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called highIsClosed in the ISO 21090 specification.

Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="INT">
		<xs:annotation>
			<xs:documentation>Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers that are results of counting and enumerating. Integer numbers are discrete, the set of integers is infinite but countable. No arbitrary limit is imposed on the range of integer numbers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence/>
				<xs:attribute name="value" use="required" type="xs:int">
					<xs:annotation>
						<xs:documentation>The value of the INT. Note that this specification imposes no limitations on the size of integer, but most implementations will map this to a 32 or 64 bit integer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_REAL">
		<xs:annotation>
			<xs:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="low" type="REAL" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the low limit. If the low limit is not known, it may be null.
The low limit SHALL NOT be positive infinity.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="high" type="REAL" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the high limit. If the high limit is not known, it may be null.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="lowIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called lowIsClosed in the ISO 21090 specification.

Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="highIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called highIsClosed in the ISO 21090 specification.

Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ADXP">
		<xs:annotation>
			<xs:documentation>A part with a type-tag signifying its role in the address. Typical parts that exist in about every address are street, house number, or post box, postal code, city, country but other roles may be defined regionally, nationally, or on an enterprise level (e.g. in military addresses). </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="XP">
				<xs:sequence/>
				<xs:attribute name="type" use="required" type="AddressPartType">
					<xs:annotation>
						<xs:documentation>Whether an address part names the street, city, country, postal code, post box, address line 1, etc.
The value of this attribute SHALL be taken from the HL7 AddressPartType code system.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TS">
		<xs:annotation>
			<xs:documentation>A quantity specifying a point on the axis of natural time. A point in time is most often represented as a calendar expression.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence/>
				<xs:attribute name="value" use="required" type="TimeStamp">
					<xs:annotation>
						<xs:documentation>The value of the TS. value is a string with the format "YYYY[MM[DD[HH[MM[SS[.U[U[U[U]]]]]]]]][+|-ZZzz]" that conforms to the constrained ISO 8601 defined in ISO 8824 (ASN.1) under clause 32 (generalized time). The format should be used to the degree of precision that is appropriate.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ENXP">
		<xs:annotation>
			<xs:documentation>A part with a type code signifying the role of the part in the whole entity name, and qualifier codes for more detail about the name part type. (Typical name parts for person names are given names, and family names, titles, etc.). </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="XP">
				<xs:sequence/>
				<xs:attribute name="type" use="required" type="EntityNamePartType">
					<xs:annotation>
						<xs:documentation>Indicates whether the name part is a given name, family name, prefix, suffix, etc. 
The value of this attribute SHALL be taken from the HL7 EntityNamePartType2 code system.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="qualifier" use="optional" type="set_EntityNamePartQualifier">
					<xs:annotation>
						<xs:documentation>The qualifier is a set of codes each of which specifies a certain subcategory of the name part in addition to the main name part type.
For example, a given name may be flagged as a nickname (CL), a family name may be a name acquired by marriage (SP) or a name from birth (BR).
If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNamePartQualifier2 code system.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BL">
		<xs:annotation>
			<xs:documentation>BL stands for the values of two-valued logic. A BL value can be either true or false.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence/>
				<xs:attribute name="value" use="required" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>The value of the BL.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="II">
		<xs:annotation>
			<xs:documentation>An identifier that uniquely identifies a thing or object. 

Examples are object identifier for HL7 RIM objects, medical record number, order id, service catalog item id, Vehicle Identification Number (VIN), etc. Instance identifiers are usually defined based on ISO object identifiers.

An identifier allows someone to select one record, object or thing from a set of candidates. Usually an identifier alone without any context is not usable. Identifiers are distinguished from concept descriptors as concept descriptors never identify an individual thing, although there may sometimes be an individual record or object that represents the concept.

Information Processing Entities claiming direct or indirect conformance SHALL never assume that receiving applications can infer the identity of issuing authority or the type of the identifier from the identifier or components thereof.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence/>
				<xs:attribute name="root" use="required" type="Uid">
					<xs:annotation>
						<xs:documentation>A unique identifier that guarantees the global uniqueness of the instance identifier. 
If root is populated, and there is no extension, then the root is a globally unique identifier in its own right. In the presence of a non-null extension, the root is the unique identifier for the "namespace" of the identifier in the extension. Note that this does NOT necessarily correlate with the organization that manages the issuing of the identifiers. A given organization may manage multiple identifier namespaces, and control over a given namespace may transfer from organization to organization over time while the root remains the same. 
This field can be either a DCE UUID, an Object Identifier (OID), or a special identifier taken from lists that may be published by ISO or HL7. 
Comparison of root values is always case sensitive. UUID's SHALL be represented in upper case, so UUID case should always be preserved. 
The root SHALL not be used to carry semantic meaning - all it does is ensure global computational uniqueness.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="extension" use="optional" type="xs:string">
					<xs:annotation>
						<xs:documentation>A character string as a unique identifier within the scope of the identifier root. 
The root and extension scheme means that the concatenation of root and extension SHALL be a globally unique identifier for the item that this II value identifies.
Some identifier schemes define certain style options to their code values. For example, the U.S. Social Security Number (SSN) is normally written with dashes that group the digits into a pattern "123-12-1234". However, the dashes are not meaningful and a SSN can also be represented as "123121234" without the dashes. In the case where identifier schemes provide for multiple representations, HL7 or ISO may make a ruling about which is the preferred form and document that ruling where that respective external identifier scheme is recognized.
If no extension attribute is provided in a non-null II, then the root is the complete unique identifier. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="identifierName" use="optional" type="xs:string">
					<xs:annotation>
						<xs:documentation>A human readable description for this identifier.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CD">
		<xs:annotation>
			<xs:documentation>A CD is a reference to a concept defined in an external code system, terminology, or ontology.

A CD may also contain an original text or phrase that served as the basis of the coding.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence/>
				<xs:attribute name="code" use="optional" type="Code">
					<xs:annotation>
						<xs:documentation>The plain code symbol defined by the code system, or an expression in a syntax defined by the code system which describes the concept. 
Code SHALL be an exact match to a plain code symbol or expression defined by the code system. If the code system defines a code or expression that includes whitespace, the code SHALL include the whitespace. An expression can only be used where the codeSystem either defines an expression syntax, or there is a generally accepted syntax for the codeSystem. A code system may be defined that only defines an expression syntax with bindings to other code Systems for the elements of the expression. 
It is at the discretion of the interpreting system whether to check for an expression instead of a simple code and evaluate the expression instead of treating the expression as a code. In some cases, it may be unclear or ambiguous whether the code represents a single symbol or an expression. This usually arises where the code system defines an expression language and then defines pre-coordinated concepts with symbols which match their expression, e.g. UCUM. In other cases, it is safe to treat the expression as a symbol. There is no guarantee that this is always safe: the definitions of the codeSystem should always be consulted to determine how to handle potential expressions.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystem" use="optional" type="Uid">
					<xs:annotation>
						<xs:documentation>The code system that defines the code, or if no code was found, the codeSystem in which no code was found. 
Code systems SHALL be referred to by a UID, which allows unambiguous reference to standard code systems and other local codesystems. Where either ISO or HL7 have assigned UID to code Systems, then these UIDs SHALL be used. Otherwise implementations SHALL use an appropriate ISO Object Identifier (OID) or UUID to construct a globally unique local coding system identifier.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystemName" use="optional" type="xs:string">
					<xs:annotation>
						<xs:documentation>The common name of the coding system. 

The code system name has no computational value. codeSystemName can never modify the meaning of codeSystem and cannot exist without codeSystem.

Information Processing Entities claiming direct or indirect conformance SHALL NOT functionally rely on codeSystemName. In addition, they MAY choose not to implement codeSystemName; but SHALL NOT reject instances because codeSystemName is present.

Note:  The purpose of a code system name is to assist an unaided human interpreter of a code value to interpret codeSystem.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="displayName" use="optional" type="xs:string">
					<xs:annotation>
						<xs:documentation>A name, title, or representation for the code or expression as it exists in the code system.
If populated, the displayName SHALL be a valid human readable representation of the concept as defined by the code system at the time of data entry. The displayName SHALL conform to any rules defined by the codingSystem; if the codeSystem does not define a human representation for the code or expression, then none can be provided. displayName is included both as a courtesy to an unaided human interpreter of a code value and as a documentation of the name used to display the concept to the user. The display name has no functional meaning; it SHALL never exist without a code; and it SHALL never modify the meaning of the code. A display name may not be present if the code is an expression for which no display name has been assigned or can be derived. Information Processing Entities claiming direct or indirect conformance MAY choose not to implement displayName but SHALL NOT reject instances because displayName is present.
Display names SHALL not alter the meaning of the code value. Therefore, display names SHOULD NOT be presented to the user on a receiving application system without ascertaining that the display name adequately represents the concept referred to by the code value. Communication SHALL NOT simply rely on the display name. The display name's main purpose is to support implementation debugging.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="originalText" use="optional" type="xs:string">
					<xs:annotation>
						<xs:documentation>The text as seen and/or selected by the user who entered the data which represents the intended meaning of the user.  This attribute is equivalent to originalText.value in the ISO 21090 model.

Note: Local implementations may influence what is required to represent that original text.

Original text can be used in a structured user interface to capture what the user saw as a representation of the code on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user. 

It is valid to use the CD datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a code. In a situation where the code is assigned sometime after the text was entered, originalText is the text or phrase used as the basis for assigning the code. 

The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.

Values of type CD MAY have a original text despite not having a code. Any CD value with no code signifies a coding exception. In this case, originalText is a name or description of the concept that was not coded. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_PQ">
		<xs:annotation>
			<xs:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="low" type="PQ" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the low limit. If the low limit is not known, it may be null.
The low limit SHALL NOT be positive infinity.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="high" type="PQ" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the high limit. If the high limit is not known, it may be null.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="lowIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called lowIsClosed in the ISO 21090 specification.

Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="highIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called highIsClosed in the ISO 21090 specification.

Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED">
		<xs:annotation>
			<xs:documentation>Data that is primarily intended for human interpretation or for further machine processing outside the scope of this specification. This includes unformatted or formatted written language, multimedia data, or structured information as defined by a different standard (e.g., XML-signatures.) 
Encapsulated data can be present in two forms, inline or by reference. The content is the same whether it is located inline or remote.Inline data is communicated or moved as part of the encapsulated data value, whereas by-reference data may reside at a different  location: a URL/URI that provides reference to the information required to locate the data. Inline data may be provided in one of 3 different ways:
&amp;#60;ul&amp;#62;
	&amp;#60;li&amp;#62;as a plain sequence of characters (value)&amp;#60;/li&amp;#62;
	&amp;#60;li&amp;#62;as a binary (a sequence of bytes) (data)&amp;#60;/li&amp;#62;
	&amp;#60;li&amp;#62;as xml content (xml)&amp;#60;/li&amp;#62;
&amp;#60;/ul&amp;#62;
Content SHALL be provided if the ED has no nullFlavor. The content may be provided in-line (using only one of value, data or xml), or it may be provided as a reference.Content may be provided in-line and a reference also may be given; in these cases, it is expected that the content of the reference will be exactly the same as the in-line content. Information Processing Entities are not required to check this, but may regard it as an error condition if the content does not match</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>A simple sequence of byte values that contains the content. (Base64 Encoded String).</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The content represented in plain XML form.

A direct representation is provided for XML. This is because this specification includes an XML serialization of the data, and this xml attribute is handled specially in the serialisation form. The xml data is not different in any semantic sense to the same data if represented in the value or data attributes.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>A URL the target of which provides the binary content.

The semantic value of an encapsulated data value is the same, regardless whether the content is present as inline content or just by reference. However, an encapsulated data value without inline content behaves differently, since any attempt to examine the content requires the data to be downloaded from the reference. An encapsulated data value may have both inline content and a reference.

If data is provded in the value, data or xml attributes, the reference SHALL point to the same data. It is an error if the data resolved through the reference does not match either the integrity check, data as provided, or data that had earlier been retrieved through the reference and then cached. The mediatype of the ED SHALL match the type returned by accessing the reference. 

The reference may contain a usablePeriod to indicate that the data may only be available for a limited period of time. Whether the reference is limited by a usablePeriod or not, the content of the reference SHALL be fixed for all time. Any application using the reference SHALL always receive the same data, or an error. The reference cannot be reused to send a different version of the same data, or different data</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>A checksum calculated over the binary data

The purpose of this property, when communicated with a reference is for anyone to validate later whether the reference still resolved to the same content that the reference resolved to when the encapsulated data value with reference was created. If the attribute is null, there is no integrityCheck.
It is an error if the data resolved through the reference does not match the integrity check. 
The integrity check is calculated according to the integrityCheckAlgorithm. By default, the Secure Hash Algorithm-1 (SHA-1) shall be used. The integrity check is binary encoded according to the rules of the integrity check algorithm. 
The integrity check is calculated over the raw binary data that is contained in the data component, or that is accessible through the reference. No transformations are made before the integrity check is calculated. If the data is compressed, the Integrity Check is calculated over the compressed data. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="description" type="ST" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>An alternative description of the media where the media is not able to be rendered. 

E.g. Short text description of an image or sound clip, etc. This attribute is not intended to be a complete substitute for the original. For complete substitutes, use the &amp;#34;translation&amp;#34; property.

The intent of this property is to allow compliance with disability requirements such as those expressed in American&amp;#39;s with Disability Act (also known as &amp;#34;Section 508&amp;#34;), where there is a requirement to provide a short text description of included media in some form that can be read by a screen reader. This is similar to a very short thumbnail with mediaType = text/plain.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="value" use="optional" type="xs:string">
					<xs:annotation>
						<xs:documentation>A simple sequence of characters that contains the content. 

If value is used, the mediatype is fixed to text/plain and the charset must be consistent with the String Character Set. Refer to section 6.7.5 for more details</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="mediaType" use="optional" default="text/plain" type="xs:string">
					<xs:annotation>
						<xs:documentation>Identifies the type of the encapsulated data and can be used to determine a method to interpret or render the content. 

The IANA defined domain of media types is established by the IETF RFCs 2045 and 2046. mediaType has a default value of text/plain and cannot be null. If the media type is different to text/plain, the &amp;#60;i&amp;#62;mediaType&amp;#60;/i&amp;#62; attribute SHALL be populated.

If the content is compressed using a specified compression algorithm, the mediaType SHALL refer the mediaType of the uncompressed data, whether the data is accessed by reference or not. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="charset" use="optional" type="Code">
					<xs:annotation>
						<xs:documentation>An Internet Assigned Numbers Authority (IANA) Charset Registered character set and character encoding for character-based encoding types&amp;#60;b&amp;#62;. &amp;#60;/b&amp;#62;

Whenever the content of the ED is character type data in any form, the charset property needs to be known. If the content is provided directly in the value attribute, then the charset SHALL be a known character set consistent with the String Character Set. Refer to section 6.7.5 for more details. If the content is provided as a reference, and the access method does not provide the charset for the content (such as by a mime header), then the charset SHALL be conveyed as part of the ED</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="language" use="optional" type="Code">
					<xs:annotation>
						<xs:documentation>The human language of the content. Valid codes are taken from the IETF RFC 3066. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.

Conformance profiles SHOULD define defaulting rules for language for a given usage environment of this specification.

Note: While language attribute usually alters the interpretation of the text, the language attribute does not alter the meaning of the characters in the text.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="integrityCheckAlgorithm" use="optional" type="IntegrityCheckAlgorithm">
					<xs:annotation>
						<xs:documentation>The algorithm used to compute the integrityCheck value.
If populated, the value of this attribute SHALL be taken from the HL7 IntegrityCheckAlgorithm code system.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CS">
		<xs:annotation>
			<xs:documentation>Coded data in its simplest form, where only the code is not predetermined. 

The code system and code system version are implied and fixed by the context in which the CS value occurs.  

Due to its highly restricted functionality, CS SHALL only be used for simple structural attributes with highly controlled and stable terminologies where:
- all codes come from a single code system
- codes are not reused if their concept is deprecated
- the publication and extensibility properties of the code system are well described and understood</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence minOccurs="1" maxOccurs="1"/>
				<xs:attribute name="code" use="required" type="xs:string">
					<xs:annotation>
						<xs:documentation>The plain code symbol defined by the code system.  If the code value is empty or null, then there is no code in the code system that represents the concept.
Code SHALL only contain characters that are either a letter, a digit, or one of '.', '-', '_' or ':'. Code systems that are used with CS SHALL NOT define code symbols or expression syntaxes that contain whitespace or any other characters not in this list.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS">
		<xs:annotation>
			<xs:documentation>A set of consecutive values of an ordered base datatype. 

Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 seconds.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="low" type="TS" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the low limit. If the low limit is not known, it may be null.
The low limit SHALL NOT be positive infinity.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="high" type="TS" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>This is the high limit. If the high limit is not known, it may be null.
The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="lowIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called lowIsClosed in the ISO 21090 specification.

Whether low is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="highIsInclusive" use="optional" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>This attribute is called highIsClosed in the ISO 21090 specification.

Whether high is included in the IVL (is closed) or excluded from the IVL (is open).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AD">
		<xs:annotation>
			<xs:documentation>Mailing and home or office addresses. 

AD is primarily used to communicate data that will allow printing mail labels, or that will allow a person to physically visit that address. The postal address datatype is not supposed to be a container for additional information that might be useful for finding geographic locations (e.g., GPS coordinates) or for performing epidemiological studies. Such additional information should be captured by other, more appropriate data structures.

Addresses are essentially sequences of address parts, but add a "use" code and a valid time range for information about if and when the address can be used for a given purpose.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="part" type="ADXP" minOccurs="1" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A sequence of address parts, such as street or post office Box, city, postal code, country, etc.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="use" use="optional" type="set_PostalAddressUse">
					<xs:annotation>
						<xs:documentation>A set of codes advising a system or user which address in a set of like addresses to select for a given purpose. 
An address without specific use code might be a default address useful for any purpose, but an address with a specific use code would be preferred for that respective purpose.
If populated, the values contained in this attribute SHALL be taken from the HL7 PostalAddressUse code system.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RTO_PQ">
		<xs:annotation>
			<xs:documentation>A quantity constructed as the quotient of a numerator quantity divided by a denominator quantity. 
Common factors in the numerator and denominator are not automatically cancelled out. 
The RTO datatype supports titers (e.g., 1:128) and other quantities produced by laboratories that truly represent ratios. Ratios are not simply structured numerics, particularly blood pressure measurements (e.g. 120/60) are not ratios.
Notes: 
1.	Ratios are different from rational numbers, i.e., in ratios common factors in the numerator and denominator never cancel out. A ratio of two real or integer numbers is not automatically reduced to a real number. This datatype is not defined to generally represent rational numbers. It is used only if common factors in numerator and denominator are not supposed to cancel out. This is only rarely the case. For observation values, ratios occur almost exclusively with titers. In most other cases, REAL should be used instead of the RTO.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="numerator" type="PQ" minOccurs="1" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The quantity that is being divided in the ratio</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="denominator" type="PQ" minOccurs="1" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>The quantity that divides the numerator in the ratio. 
The denominator SHALL not be zero.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="Uid">
		<xs:annotation>
			<xs:documentation>OID or GUID</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:simpleType name="Decimal">
		<xs:restriction base="xs:double"/>
	</xs:simpleType>
	<xs:simpleType name="TimeStamp">
		<xs:annotation>
			<xs:documentation>20101127235417.123+0930</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9])|(3[0-1]))((([0-1][0-9])|(2[0-3]))(([0-5][0-9])(([0-5][0-9])(\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EntityNamePartType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="FAM"/>
			<xs:enumeration value="GIV"/>
			<xs:enumeration value="TITLE"/>
			<xs:enumeration value="DEL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EntityNamePartQualifier">
		<xs:restriction base="xs:string">
			<xs:enumeration value="LS"/>
			<xs:enumeration value="AC"/>
			<xs:enumeration value="NB"/>
			<xs:enumeration value="PR"/>
			<xs:enumeration value="HON"/>
			<xs:enumeration value="BR"/>
			<xs:enumeration value="AD"/>
			<xs:enumeration value="SP"/>
			<xs:enumeration value="MID"/>
			<xs:enumeration value="CL"/>
			<xs:enumeration value="IN"/>
			<xs:enumeration value="PFX"/>
			<xs:enumeration value="SFX"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="set_EntityNamePartQualifier">
		<xs:list itemType="dt:EntityNamePartQualifier"/>
	</xs:simpleType>
	<xs:simpleType name="AddressPartType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AL"/>
			<xs:enumeration value="ADL"/>
			<xs:enumeration value="UNID"/>
			<xs:enumeration value="UNIT"/>
			<xs:enumeration value="DAL"/>
			<xs:enumeration value="DINST"/>
			<xs:enumeration value="DINSTA"/>
			<xs:enumeration value="DINSTQ"/>
			<xs:enumeration value="DMOD"/>
			<xs:enumeration value="DMODID"/>
			<xs:enumeration value="SAL"/>
			<xs:enumeration value="BNR"/>
			<xs:enumeration value="BNN"/>
			<xs:enumeration value="BNS"/>
			<xs:enumeration value="STR"/>
			<xs:enumeration value="STB"/>
			<xs:enumeration value="STTYP"/>
			<xs:enumeration value="DIR"/>
			<xs:enumeration value="INT"/>
			<xs:enumeration value="CAR"/>
			<xs:enumeration value="CEN"/>
			<xs:enumeration value="CNT"/>
			<xs:enumeration value="CPA"/>
			<xs:enumeration value="CTY"/>
			<xs:enumeration value="DEL"/>
			<xs:enumeration value="POB"/>
			<xs:enumeration value="PRE"/>
			<xs:enumeration value="STA"/>
			<xs:enumeration value="ZIP"/>
			<xs:enumeration value="DPID"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TelecommunicationAddressUse">
		<xs:restriction base="xs:string">
			<xs:enumeration value="H"/>
			<xs:enumeration value="HP"/>
			<xs:enumeration value="HV"/>
			<xs:enumeration value="WP"/>
			<xs:enumeration value="DIR"/>
			<xs:enumeration value="PUB"/>
			<xs:enumeration value="BAD"/>
			<xs:enumeration value="TMP"/>
			<xs:enumeration value="AS"/>
			<xs:enumeration value="EC"/>
			<xs:enumeration value="MC"/>
			<xs:enumeration value="PG"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TelecommunicationCapability">
		<xs:restriction base="xs:string">
			<xs:enumeration value="voice"/>
			<xs:enumeration value="fax"/>
			<xs:enumeration value="data"/>
			<xs:enumeration value="tty"/>
			<xs:enumeration value="sms"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PostalAddressUse">
		<xs:restriction base="xs:string">
			<xs:enumeration value="H"/>
			<xs:enumeration value="HP"/>
			<xs:enumeration value="HV"/>
			<xs:enumeration value="WP"/>
			<xs:enumeration value="DIR"/>
			<xs:enumeration value="PUB"/>
			<xs:enumeration value="BAD"/>
			<xs:enumeration value="PHYS"/>
			<xs:enumeration value="PST"/>
			<xs:enumeration value="TMP"/>
			<xs:enumeration value="ABC"/>
			<xs:enumeration value="IDE"/>
			<xs:enumeration value="SYL"/>
			<xs:enumeration value="SRCH"/>
			<xs:enumeration value="SNDX"/>
			<xs:enumeration value="PHON"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IntegrityCheckAlgorithm">
		<xs:restriction base="xs:string">
			<xs:enumeration value="SHA1"/>
			<xs:enumeration value="SHA256"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EntityNameUse">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ABC"/>
			<xs:enumeration value="SYL"/>
			<xs:enumeration value="IDE"/>
			<xs:enumeration value="C"/>
			<xs:enumeration value="OR"/>
			<xs:enumeration value="T"/>
			<xs:enumeration value="I"/>
			<xs:enumeration value="P"/>
			<xs:enumeration value="ANON"/>
			<xs:enumeration value="A"/>
			<xs:enumeration value="R"/>
			<xs:enumeration value="OLD"/>
			<xs:enumeration value="DN"/>
			<xs:enumeration value="M"/>
			<xs:enumeration value="SRCH"/>
			<xs:enumeration value="PHON"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="set_PostalAddressUse">
		<xs:list itemType="dt:PostalAddressUse"/>
	</xs:simpleType>
	<xs:simpleType name="set_EntityNameUse">
		<xs:list itemType="dt:EntityNameUse"/>
	</xs:simpleType>
	<xs:simpleType name="set_TelecommunicationAddressUse">
		<xs:list itemType="dt:TelecommunicationAddressUse"/>
	</xs:simpleType>
	<xs:simpleType name="set_TelecommunicationCapability">
		<xs:list itemType="dt:TelecommunicationCapability"/>
	</xs:simpleType>
	<xs:simpleType name="UncertaintyType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="U"/>
			<xs:enumeration value="N"/>
			<xs:enumeration value="LN"/>
			<xs:enumeration value="G"/>
			<xs:enumeration value="E"/>
			<xs:enumeration value="X2"/>
			<xs:enumeration value="T"/>
			<xs:enumeration value="F"/>
			<xs:enumeration value="B"/>
		</xs:restriction>
	</xs:simpleType>
</xs:schema>
